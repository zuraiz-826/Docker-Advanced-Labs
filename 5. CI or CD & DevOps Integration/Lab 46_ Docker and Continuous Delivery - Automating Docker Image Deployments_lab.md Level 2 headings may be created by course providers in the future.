Lab 46: Docker and Continuous Delivery - Automating Docker Image Deployments
Lab Objectives
By the end of this lab, students will be able to:

Integrate Docker with Jenkins to create a complete CI/CD pipeline
Configure automatic deployments of Docker images to Docker Hub registry
Build and deploy Jenkins pipelines for Docker image management
Deploy Docker containers to AWS EC2 instances using automation
Implement vulnerability scanning within the continuous delivery pipeline
Understand best practices for Docker-based continuous delivery workflows
Prerequisites
Before starting this lab, students should have:

Basic understanding of Docker concepts (containers, images, Dockerfile)
Familiarity with Linux command line operations
Basic knowledge of Git version control
Understanding of CI/CD concepts
AWS account with basic EC2 knowledge (for deployment tasks)
Docker Hub account (free registration available)
Lab Environment Setup
Ready-to-Use Cloud Machines: Al Nafi provides pre-configured Linux-based cloud machines with all necessary tools installed. Simply click Start Lab to access your environment. No need to build your own VM or install software manually.

Your lab environment includes:

Ubuntu 20.04 LTS with Docker pre-installed
Jenkins server ready for configuration
Git and other essential development tools
AWS CLI configured for EC2 deployments
Task 1: Integrate Docker with Jenkins for CI/CD
Subtask 1.1: Configure Jenkins for Docker Integration
First, let's ensure Jenkins has the necessary plugins and permissions to work with Docker.

Access Jenkins Dashboard

# Jenkins should be running on your lab machine
# Access via browser at: http://localhost:8080
# Default credentials will be provided in your lab environment
Install Required Jenkins Plugins

Navigate to Manage Jenkins > Manage Plugins
Go to Available tab and search for:
Docker Pipeline
Docker plugin
Pipeline: Stage View
Install these plugins and restart Jenkins
Add Jenkins User to Docker Group

sudo usermod -aG docker jenkins
sudo systemctl restart jenkins
Verify Docker Access from Jenkins

# Test Docker access
sudo -u jenkins docker --version
sudo -u jenkins docker ps
Subtask 1.2: Create Sample Application for CI/CD
Create Project Directory

mkdir ~/docker-cicd-demo
cd ~/docker-cicd-demo
Create Simple Node.js Application

# Create package.json
cat > package.json << 'EOF'
{
  "name": "docker-cicd-demo",
  "version": "1.0.0",
  "description": "Demo app for Docker CI/CD",
  "main": "app.js",
  "scripts": {
    "start": "node app.js",
    "test": "echo \"Test passed\" && exit 0"
  },
  "dependencies": {
    "express": "^4.18.0"
  }
}
EOF
Create Application File

cat > app.js << 'EOF'
const express = require('express');
const app = express();
const port = 3000;

app.get('/', (req, res) => {
  res.json({
    message: 'Hello from Docker CI/CD Demo!',
    version: '1.0.0',
    timestamp: new Date().toISOString()
  });
});

app.get('/health', (req, res) => {
  res.status(200).json({ status: 'healthy' });
});

app.listen(port, '0.0.0.0', () => {
  console.log(`App running on port ${port}`);
});
EOF
Create Dockerfile

cat > Dockerfile << 'EOF'
FROM node:16-alpine

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm install --only=production

# Copy application code
COPY . .

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# Start application
CMD ["npm", "start"]
EOF
Initialize Git Repository

git init
git add .
git commit -m "Initial commit: Docker CI/CD demo application"
Task 2: Set up Automatic Deployments to Docker Hub
Subtask 2.1: Configure Docker Hub Credentials in Jenkins
Create Docker Hub Repository

Log into Docker Hub (hub.docker.com)
Create new repository: your-username/docker-cicd-demo
Make it public for this demo
Add Docker Hub Credentials to Jenkins

Go to Manage Jenkins > Manage Credentials
Click Global > Add Credentials
Select Username with password
Enter your Docker Hub credentials
ID: dockerhub-credentials
Subtask 2.2: Create Docker Build and Push Scripts
Create Build Script

cat > build-docker.sh << 'EOF'
#!/bin/bash
set -e

# Variables
IMAGE_NAME="your-dockerhub-username/docker-cicd-demo"
BUILD_NUMBER=${BUILD_NUMBER:-latest}
GIT_COMMIT=${GIT_COMMIT:-$(git rev-parse HEAD)}

echo "Building Docker image..."
docker build -t ${IMAGE_NAME}:${BUILD_NUMBER} .
docker build -t ${IMAGE_NAME}:latest .

echo "Tagging image with git commit..."
docker tag ${IMAGE_NAME}:${BUILD_NUMBER} ${IMAGE_NAME}:${GIT_COMMIT:0:8}

echo "Build completed successfully!"
EOF

chmod +x build-docker.sh
Create Push Script

cat > push-docker.sh << 'EOF'
#!/bin/bash
set -e

# Variables
IMAGE_NAME="your-dockerhub-username/docker-cicd-demo"
BUILD_NUMBER=${BUILD_NUMBER:-latest}
GIT_COMMIT=${GIT_COMMIT:-$(git rev-parse HEAD)}

echo "Pushing Docker images to Docker Hub..."
docker push ${IMAGE_NAME}:${BUILD_NUMBER}
docker push ${IMAGE_NAME}:latest
docker push ${IMAGE_NAME}:${GIT_COMMIT:0:8}

echo "Images pushed successfully!"
EOF

chmod +x push-docker.sh
Task 3: Create Jenkins Pipeline for Building and Deploying Docker Images
Subtask 3.1: Create Jenkinsfile
Create Pipeline Configuration
cat > Jenkinsfile << 'EOF'
pipeline {
    agent any
    
    environment {
        DOCKER_IMAGE = 'your-dockerhub-username/docker-cicd-demo'
        DOCKER_CREDENTIALS = 'dockerhub-credentials'
        BUILD_NUMBER = "${env.BUILD_NUMBER}"
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo 'Checking out source code...'
                checkout scm
            }
        }
        
        stage('Test') {
            steps {
                echo 'Running tests...'
                sh 'npm test'
            }
        }
        
        stage('Build Docker Image') {
            steps {
                echo 'Building Docker image...'
                script {
                    def image = docker.build("${DOCKER_IMAGE}:${BUILD_NUMBER}")
                    docker.build("${DOCKER_IMAGE}:latest")
                }
            }
        }
        
        stage('Security Scan') {
            steps {
                echo 'Running security scan...'
                sh '''
                    # Install Trivy if not present
                    if ! command -v trivy &> /dev/null; then
                        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
                        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
                        sudo apt-get update
                        sudo apt-get install trivy -y
                    fi
                    
                    # Scan the image
                    trivy image --exit-code 0 --severity HIGH,CRITICAL ${DOCKER_IMAGE}:${BUILD_NUMBER}
                '''
            }
        }
        
        stage('Push to Docker Hub') {
            steps {
                echo 'Pushing to Docker Hub...'
                script {
                    docker.withRegistry('https://registry.hub.docker.com', DOCKER_CREDENTIALS) {
                        def image = docker.image("${DOCKER_IMAGE}:${BUILD_NUMBER}")
                        image.push()
                        image.push("latest")
                        
                        // Tag with git commit
                        def gitCommit = sh(returnStdout: true, script: 'git rev-parse HEAD').trim()
                        image.push(gitCommit.take(8))
                    }
                }
            }
        }
        
        stage('Deploy to Staging') {
            steps {
                echo 'Deploying to staging environment...'
                sh '''
                    # Stop existing container if running
                    docker stop docker-cicd-staging || true
                    docker rm docker-cicd-staging || true
                    
                    # Run new container
                    docker run -d --name docker-cicd-staging -p 3001:3000 ${DOCKER_IMAGE}:${BUILD_NUMBER}
                    
                    # Wait for container to be ready
                    sleep 10
                    
                    # Health check
                    curl -f http://localhost:3001/health || exit 1
                '''
            }
        }
    }
    
    post {
        always {
            echo 'Cleaning up...'
            sh 'docker system prune -f'
        }
        success {
            echo 'Pipeline completed successfully!'
        }
        failure {
            echo 'Pipeline failed!'
        }
    }
}
EOF
Subtask 3.2: Create Jenkins Pipeline Job
Create New Pipeline Job

Go to Jenkins Dashboard
Click New Item
Enter name: docker-cicd-pipeline
Select Pipeline and click OK
Configure Pipeline

In Pipeline section, select Pipeline script from SCM
SCM: Git
Repository URL: Use your local git repository path or create a GitHub repo
Script Path: Jenkinsfile
Save the configuration
Commit Pipeline Files

git add .
git commit -m "Add Jenkins pipeline configuration"
Task 4: Deploy Docker Containers to AWS EC2 Instances
Subtask 4.1: Prepare EC2 Instance for Deployment
Create EC2 Deployment Script
cat > deploy-to-ec2.sh << 'EOF'
#!/bin/bash
set -e

# Configuration
EC2_HOST="your-ec2-public-ip"
EC2_USER="ubuntu"
KEY_PATH="~/.ssh/your-key.pem"
IMAGE_NAME="your-dockerhub-username/docker-cicd-demo"
BUILD_NUMBER=${BUILD_NUMBER:-latest}

echo "Deploying to EC2 instance: ${EC2_HOST}"

# Deploy via SSH
ssh -i ${KEY_PATH} -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} << EOF
    # Update system and install Docker if needed
    sudo apt-get update
    
    # Install Docker if not present
    if ! command -v docker &> /dev/null; then
        curl -fsSL https://get.docker.com -o get-docker.sh
        sudo sh get-docker.sh
        sudo usermod -aG docker ubuntu
    fi
    
    # Pull latest image
    docker pull ${IMAGE_NAME}:${BUILD_NUMBER}
    
    # Stop existing container
    docker stop docker-cicd-prod || true
    docker rm docker-cicd-prod || true
    
    # Run new container
    docker run -d --name docker-cicd-prod -p 80:3000 --restart unless-stopped ${IMAGE_NAME}:${BUILD_NUMBER}
    
    # Verify deployment
    sleep 10
    curl -f http://localhost/health || exit 1
    
    echo "Deployment completed successfully!"
EOF
EOF

chmod +x deploy-to-ec2.sh
Subtask 4.2: Add EC2 Deployment Stage to Pipeline
Update Jenkinsfile with EC2 Deployment
cat >> Jenkinsfile << 'EOF'
        
        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            steps {
                echo 'Deploying to production EC2...'
                script {
                    // Add EC2 SSH credentials to Jenkins first
                    sshagent(['ec2-ssh-key']) {
                        sh '''
                            ssh -o StrictHostKeyChecking=no ubuntu@your-ec2-ip << 'ENDSSH'
                                # Pull and deploy latest image
                                docker pull ${DOCKER_IMAGE}:${BUILD_NUMBER}
                                docker stop docker-cicd-prod || true
                                docker rm docker-cicd-prod || true
                                docker run -d --name docker-cicd-prod -p 80:3000 --restart unless-stopped ${DOCKER_IMAGE}:${BUILD_NUMBER}
                                
                                # Health check
                                sleep 10
                                curl -f http://localhost/health
ENDSSH
                        '''
                    }
                }
            }
        }
EOF
Subtask 4.3: Configure AWS CLI for Automated EC2 Management
Create EC2 Instance Management Script
cat > manage-ec2.sh << 'EOF'
#!/bin/bash

# AWS EC2 management for Docker deployments
INSTANCE_ID="i-1234567890abcdef0"  # Replace with your instance ID
REGION="us-east-1"  # Replace with your region

case "$1" in
    start)
        echo "Starting EC2 instance..."
        aws ec2 start-instances --instance-ids $INSTANCE_ID --region $REGION
        aws ec2 wait instance-running --instance-ids $INSTANCE_ID --region $REGION
        echo "Instance started successfully"
        ;;
    stop)
        echo "Stopping EC2 instance..."
        aws ec2 stop-instances --instance-ids $INSTANCE_ID --region $REGION
        aws ec2 wait instance-stopped --instance-ids $INSTANCE_ID --region $REGION
        echo "Instance stopped successfully"
        ;;
    status)
        aws ec2 describe-instances --instance-ids $INSTANCE_ID --region $REGION --query 'Reservations[0].Instances[0].State.Name' --output text
        ;;
    ip)
        aws ec2 describe-instances --instance-ids $INSTANCE_ID --region $REGION --query 'Reservations[0].Instances[0].PublicIpAddress' --output text
        ;;
    *)
        echo "Usage: $0 {start|stop|status|ip}"
        exit 1
        ;;
esac
EOF

chmod +x manage-ec2.sh
Task 5: Automate Vulnerability Scanning within the CD Pipeline
Subtask 5.1: Integrate Trivy Security Scanner
Create Security Scanning Script
cat > security-scan.sh << 'EOF'
#!/bin/bash
set -e

IMAGE_NAME=$1
REPORT_FORMAT=${2:-table}
SEVERITY=${3:-HIGH,CRITICAL}

if [ -z "$IMAGE_NAME" ]; then
    echo "Usage: $0 <image-name> [report-format] [severity]"
    exit 1
fi

echo "Running security scan on image: $IMAGE_NAME"

# Install Trivy if not present
if ! command -v trivy &> /dev/null; then
    echo "Installing Trivy..."
    sudo apt-get update
    sudo apt-get install wget apt-transport-https gnupg lsb-release -y
    wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
    echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
    sudo apt-get update
    sudo apt-get install trivy -y
fi

# Create reports directory
mkdir -p reports

# Run vulnerability scan
echo "Scanning for vulnerabilities..."
trivy image --format $REPORT_FORMAT --severity $SEVERITY --output reports/security-report.txt $IMAGE_NAME

# Generate JSON report for CI/CD integration
trivy image --format json --severity $SEVERITY --output reports/security-report.json $IMAGE_NAME

# Check if critical vulnerabilities found
CRITICAL_COUNT=$(trivy image --format json --severity CRITICAL $IMAGE_NAME | jq '.Results[]?.Vulnerabilities // [] | length' | awk '{sum+=$1} END {print sum+0}')

echo "Critical vulnerabilities found: $CRITICAL_COUNT"

if [ "$CRITICAL_COUNT" -gt 0 ]; then
    echo "WARNING: Critical vulnerabilities detected!"
    echo "Review the security report before proceeding with deployment."
    # Uncomment the next line to fail the build on critical vulnerabilities
    # exit 1
fi

echo "Security scan completed. Reports saved in reports/ directory."
EOF

chmod +x security-scan.sh
Subtask 5.2: Add Advanced Security Pipeline Stage
Create Enhanced Security Jenkinsfile Stage
cat > security-pipeline-stage.groovy << 'EOF'
stage('Advanced Security Scan') {
    parallel {
        stage('Vulnerability Scan') {
            steps {
                echo 'Running Trivy vulnerability scan...'
                sh '''
                    ./security-scan.sh ${DOCKER_IMAGE}:${BUILD_NUMBER} json HIGH,CRITICAL
                    
                    # Archive security reports
                    mkdir -p reports
                    cp reports/security-report.* . || true
                '''
                
                // Archive reports
                archiveArtifacts artifacts: 'security-report.*', allowEmptyArchive: true
                
                // Publish security report
                publishHTML([
                    allowMissing: false,
                    alwaysLinkToLastBuild: true,
                    keepAll: true,
                    reportDir: 'reports',
                    reportFiles: 'security-report.txt',
                    reportName: 'Security Scan Report'
                ])
            }
        }
        
        stage('Container Compliance') {
            steps {
                echo 'Checking container compliance...'
                sh '''
                    # Check if container runs as non-root
                    docker run --rm ${DOCKER_IMAGE}:${BUILD_NUMBER} whoami | grep -v root || echo "WARNING: Container runs as root"
                    
                    # Check for security best practices
                    docker history ${DOCKER_IMAGE}:${BUILD_NUMBER} --no-trunc | grep -i "add\|copy" | wc -l
                '''
            }
        }
    }
}
EOF
Subtask 5.3: Create Security Policy Configuration
Create Security Policy File
cat > security-policy.yaml << 'EOF'
# Security policy for Docker CI/CD pipeline
security:
  vulnerability_scanning:
    enabled: true
    fail_on_critical: false  # Set to true to fail build on critical vulnerabilities
    severity_levels:
      - HIGH
      - CRITICAL
    
  container_compliance:
    enabled: true
    checks:
      - non_root_user
      - no_secrets_in_image
      - minimal_base_image
      - health_check_present
    
  registry_security:
    enabled: true
    scan_on_push: true
    quarantine_vulnerable_images: false

notifications:
  security_alerts:
    enabled: true
    channels:
      - email
      - slack  # Configure webhook URL
EOF
Subtask 5.4: Test Complete CI/CD Pipeline
Run Full Pipeline Test

# Commit all changes
git add .
git commit -m "Complete CI/CD pipeline with security scanning"

# Test local build
./build-docker.sh

# Test security scan
./security-scan.sh your-dockerhub-username/docker-cicd-demo:latest

# Verify application works
docker run -d --name test-app -p 3002:3000 your-dockerhub-username/docker-cicd-demo:latest
sleep 5
curl http://localhost:3002/health
docker stop test-app && docker rm test-app
Trigger Jenkins Pipeline

Go to Jenkins Dashboard
Click on your docker-cicd-pipeline job
Click Build Now
Monitor the pipeline execution through each stage
Verify Deployment

# Check if staging deployment is running
curl http://localhost:3001/health

# Check Docker Hub for pushed images
docker search your-dockerhub-username/docker-cicd-demo
Troubleshooting Common Issues
Docker Permission Issues
# If Jenkins can't access Docker
sudo usermod -aG docker jenkins
sudo systemctl restart jenkins
Pipeline Fails at Security Scan
# Install missing dependencies
sudo apt-get update
sudo apt-get install curl wget jq -y
EC2 Connection Issues
# Verify SSH key permissions
chmod 400 ~/.ssh/your-key.pem

# Test SSH connection
ssh -i ~/.ssh/your-key.pem ubuntu@your-ec2-ip
Docker Hub Push Failures
# Login manually to test credentials
docker login
docker push your-dockerhub-username/docker-cicd-demo:test
Lab Validation
To verify your lab completion:

Check Jenkins Pipeline Success

All pipeline stages should complete successfully
Security scan reports should be generated
Images should be pushed to Docker Hub
Verify Docker Hub Repository

Images with different tags should be visible
Latest tag should point to most recent build
Test Application Deployment

Staging environment should be accessible
Health check endpoint should return success
Application should serve expected responses
Security Scan Results

Security reports should be generated
Vulnerability counts should be documented
No critical security issues should block deployment
Conclusion
In this comprehensive lab, you have successfully:

Integrated Docker with Jenkins to create a robust CI/CD pipeline that automates the entire software delivery process
Configured automatic deployments to Docker Hub, ensuring your images are always available in a central registry
Built a complete Jenkins pipeline that handles building, testing, security scanning, and deployment of Docker images
Deployed containers to AWS EC2 instances using automated scripts and infrastructure management
Implemented vulnerability scanning within your CD pipeline to maintain security standards throughout the deployment process
This lab demonstrates real-world DevOps practices that are essential for modern software development teams. The automated pipeline you've created reduces manual errors, increases deployment frequency, and maintains consistent security standards across all environments.

Key Benefits Achieved:

Faster Time to Market: Automated pipelines reduce deployment time from hours to minutes
Improved Security: Integrated vulnerability scanning catches issues before production
Consistent Deployments: Standardized processes eliminate environment-specific issues
Better Collaboration: Clear pipeline stages improve team communication and accountability
These skills are directly applicable to Docker Certified Associate (DCA) certification requirements and are highly valued in the current job market for DevOps engineers, Site Reliability Engineers, and Cloud Architects.

Next Steps: Consider extending this pipeline with additional features like:

Multi-environment deployments (dev, staging, production)
Blue-green deployment strategies
Kubernetes integration for container orchestration
Advanced monitoring and alerting systems
