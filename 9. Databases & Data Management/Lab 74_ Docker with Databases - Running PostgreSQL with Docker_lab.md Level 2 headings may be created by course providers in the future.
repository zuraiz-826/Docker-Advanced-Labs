```markdown
# ðŸ˜ Lab 74: Docker with Databases - Running PostgreSQL with Docker

## ðŸ“¦ Quick Overview
```

1. Pull PostgreSQL Docker image
2. Run container with persistent storage
3. Connect via custom Docker network
4. Test with Python/Node.js apps
5. Manage with migration scripts

```

## ðŸŽ¯ Objectives
By the end of this lab, you will be able to:

- âœ… Deploy PostgreSQL database inside a Docker container for development and testing environments
- âœ… Configure persistent storage using Docker volumes to maintain data across container restarts
- âœ… Connect PostgreSQL container with web application containers using Docker networking
- âœ… Establish database connections from Python and Node.js applications
- âœ… Perform database migrations and management tasks using Docker containers
- âœ… Understand best practices for running databases in containerized environments

## ðŸ“‹ Prerequisites
Before starting this lab, you should have:

- ðŸ”§ Basic understanding of Docker concepts (containers, images, volumes)
- ðŸ’» Familiarity with command-line interface operations
- ðŸ—„ï¸ Basic knowledge of SQL and database concepts
- ðŸ Understanding of Python or Node.js programming fundamentals
- ðŸ“ Experience with text editors for configuration files

## â˜ï¸ Ready-to-Use Cloud Machines
**Al Nafi** provides pre-configured Linux-based cloud machines with Docker already installed. Simply click **Start Lab** to access your environment - no need to build your own virtual machine or install Docker manually.

Your lab environment includes:

- ðŸ§ Ubuntu Linux with Docker Engine pre-installed
- ðŸ› ï¸ All necessary development tools and text editors
- ðŸŒ Network access for downloading Docker images
- ðŸ’¾ Sufficient storage space for containers and volumes

---

## ðŸ“ Lab Tasks

### ðŸŽ® Task 1: Pull the PostgreSQL Docker Image

#### Step 1.1: Verify Docker Installation
First, let's confirm Docker is running properly in your environment.

```bash
docker --version
docker info
```

Step 1.2: Pull the Official PostgreSQL Image

Download the latest PostgreSQL Docker image from Docker Hub.

```bash
docker pull postgres:15
```

ðŸ“ Note: We're using PostgreSQL version 15, which is stable and widely supported. You can also use postgres:latest for the most recent version.

Step 1.3: Verify the Image Download

Check that the PostgreSQL image has been downloaded successfully.

```bash
docker images | grep postgres
```

You should see output similar to:

```
postgres    15    [IMAGE_ID]    [CREATED]    [SIZE]
```

---

ðŸ”— Task 2: Run PostgreSQL Container and Link with Web Application

Step 2.1: Create a Docker Network

Create a custom network to enable communication between containers.

```bash
docker network create webapp-network
```

Step 2.2: Run PostgreSQL Container

Start the PostgreSQL container with proper configuration.

```bash
docker run -d \
  --name postgres-db \
  --network webapp-network \
  -e POSTGRES_DB=webapp_db \
  -e POSTGRES_USER=webapp_user \
  -e POSTGRES_PASSWORD=secure_password123 \
  -p 5432:5432 \
  postgres:15
```

ðŸ”§ Environment Variables Explanation:

Â· POSTGRES_DB: Creates a database named 'webapp_db'
Â· POSTGRES_USER: Creates a user named 'webapp_user'
Â· POSTGRES_PASSWORD: Sets the password for the user
Â· -p 5432:5432: Maps container port 5432 to host port 5432

Step 2.3: Verify Container is Running

Check that the PostgreSQL container is running properly.

```bash
docker ps
docker logs postgres-db
```

Step 2.4: Test Database Connection

Connect to the PostgreSQL database to verify it's working.

```bash
docker exec -it postgres-db psql -U webapp_user -d webapp_db
```

Once connected, run a simple SQL command:

```sql
SELECT version();
\q
```

---

ðŸ’¾ Task 3: Configure Persistent Storage Using Docker Volumes

Step 3.1: Stop the Current Container

Stop the existing container to recreate it with persistent storage.

```bash
docker stop postgres-db
docker rm postgres-db
```

Step 3.2: Create a Named Volume

Create a Docker volume for persistent data storage.

```bash
docker volume create postgres-data
```

Step 3.3: Run PostgreSQL with Persistent Storage

Start PostgreSQL container with the volume mounted.

```bash
docker run -d \
  --name postgres-db \
  --network webapp-network \
  -e POSTGRES_DB=webapp_db \
  -e POSTGRES_USER=webapp_user \
  -e POSTGRES_PASSWORD=secure_password123 \
  -p 5432:5432 \
  -v postgres-data:/var/lib/postgresql/data \
  postgres:15
```

Step 3.4: Test Data Persistence

Create a test table and data to verify persistence.

```bash
docker exec -it postgres-db psql -U webapp_user -d webapp_db
```

In the PostgreSQL prompt:

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
);

INSERT INTO users (name, email) VALUES 
    ('John Doe', 'john@example.com'),
    ('Jane Smith', 'jane@example.com');

SELECT * FROM users;
\q
```

Step 3.5: Verify Persistence

Restart the container and check if data persists.

```bash
docker restart postgres-db
docker exec -it postgres-db psql -U webapp_user -d webapp_db -c "SELECT * FROM users;"
```

---

ðŸ”Œ Task 4: Connect to Database from Applications

Step 4.1: Create Python Application

Create a directory for your Python application.

```bash
mkdir python-app
cd python-app
```

Create a Python script to connect to PostgreSQL:

```python
cat > app.py << 'EOF'
import psycopg2
import sys

def connect_to_database():
    try:
        # Database connection parameters
        connection = psycopg2.connect(
            host="localhost",
            database="webapp_db",
            user="webapp_user",
            password="secure_password123",
            port="5432"
        )
        
        cursor = connection.cursor()
        
        # Test the connection
        cursor.execute("SELECT version();")
        db_version = cursor.fetchone()
        print(f"Connected to PostgreSQL: {db_version[0]}")
        
        # Query users table
        cursor.execute("SELECT * FROM users;")
        users = cursor.fetchall()
        
        print("\nUsers in database:")
        for user in users:
            print(f"ID: {user[0]}, Name: {user[1]}, Email: {user[2]}")
        
        cursor.close()
        connection.close()
        print("\nDatabase connection closed.")
        
    except Exception as error:
        print(f"Error connecting to PostgreSQL: {error}")
        sys.exit(1)

if __name__ == "__main__":
    connect_to_database()
EOF
```

Step 4.2: Create Python Application Container

Create a Dockerfile for the Python application:

```dockerfile
cat > Dockerfile << 'EOF'
FROM python:3.9-slim

WORKDIR /app

RUN pip install psycopg2-binary

COPY app.py .

CMD ["python", "app.py"]
EOF
```

Step 4.3: Build and Run Python Application

Build the Python application container:

```bash
docker build -t python-db-app .
```

Run the Python application container:

```bash
docker run --rm --network webapp-network python-db-app
```

Step 4.4: Create Node.js Application

Navigate back to the main directory and create a Node.js application:

```bash
cd ..
mkdir nodejs-app
cd nodejs-app
```

Create a Node.js application:

```javascript
cat > app.js << 'EOF'
const { Client } = require('pg');

async function connectToDatabase() {
    const client = new Client({
        host: 'postgres-db',
        database: 'webapp_db',
        user: 'webapp_user',
        password: 'secure_password123',
        port: 5432,
    });

    try {
        await client.connect();
        console.log('Connected to PostgreSQL database');

        // Test query
        const versionResult = await client.query('SELECT version()');
        console.log('Database version:', versionResult.rows[0].version);

        // Query users
        const usersResult = await client.query('SELECT * FROM users');
        console.log('\nUsers in database:');
        usersResult.rows.forEach(user => {
            console.log(`ID: ${user.id}, Name: ${user.name}, Email: ${user.email}`);
        });

    } catch (error) {
        console.error('Database connection error:', error);
    } finally {
        await client.end();
        console.log('Database connection closed');
    }
}

connectToDatabase();
EOF
```

Create package.json:

```json
cat > package.json << 'EOF'
{
    "name": "nodejs-db-app",
    "version": "1.0.0",
    "description": "Node.js PostgreSQL connection example",
    "main": "app.js",
    "dependencies": {
        "pg": "^8.8.0"
    }
}
EOF
```

Create Dockerfile for Node.js:

```dockerfile
cat > Dockerfile << 'EOF'
FROM node:16-slim

WORKDIR /app

COPY package.json .
RUN npm install

COPY app.js .

CMD ["node", "app.js"]
EOF
```

Step 4.5: Build and Run Node.js Application

Build and run the Node.js application:

```bash
docker build -t nodejs-db-app .
docker run --rm --network webapp-network nodejs-db-app
```

---

ðŸš€ Task 5: Perform Database Migrations Using Docker

Step 5.1: Create Migration Scripts

Navigate back to the main directory and create a migrations folder:

```bash
cd ..
mkdir migrations
cd migrations
```

Create migration scripts:

Migration 1:

```sql
cat > 001_create_products_table.sql << 'EOF'
-- Migration: Create products table
CREATE TABLE IF NOT EXISTS products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insert sample data
INSERT INTO products (name, price, description) VALUES
    ('Laptop', 999.99, 'High-performance laptop'),
    ('Mouse', 29.99, 'Wireless optical mouse'),
    ('Keyboard', 79.99, 'Mechanical keyboard');
EOF
```

Migration 2:

```sql
cat > 002_add_category_to_products.sql << 'EOF'
-- Migration: Add category column to products table
ALTER TABLE products ADD COLUMN IF NOT EXISTS category VARCHAR(100);

-- Update existing products with categories
UPDATE products SET category = 'Electronics' WHERE name IN ('Laptop', 'Mouse', 'Keyboard');
EOF
```

Step 5.2: Create Migration Runner Script

Create a script to run migrations:

```bash
cat > run_migrations.sh << 'EOF'
#!/bin/bash

echo "Starting database migrations..."

# Run each migration file
for migration_file in /migrations/*.sql; do
    if [ -f "$migration_file" ]; then
        echo "Running migration: $(basename $migration_file)"
        psql -U webapp_user -d webapp_db -f "$migration_file"
        if [ $? -eq 0 ]; then
            echo "Migration $(basename $migration_file) completed successfully"
        else
            echo "Migration $(basename $migration_file) failed"
            exit 1
        fi
    fi
done

echo "All migrations completed successfully!"
EOF
```

Make the script executable:

```bash
chmod +x run_migrations.sh
```

Step 5.3: Run Migrations Using Docker

Execute the migrations by mounting the migrations directory:

```bash
docker run --rm \
  --network webapp-network \
  -v $(pwd):/migrations \
  postgres:15 \
  bash -c "
    export PGPASSWORD=secure_password123
    /migrations/run_migrations.sh
  "
```

Step 5.4: Verify Migration Results

Check that the migrations were applied successfully:

```bash
docker exec -it postgres-db psql -U webapp_user -d webapp_db
```

In the PostgreSQL prompt:

```sql
-- Check products table structure
\d products

-- View products data
SELECT * FROM products;

-- Check users table still exists
SELECT * FROM users;

\q
```

Step 5.5: Create a Migration Container

For more complex scenarios, create a dedicated migration container:

```dockerfile
cat > Dockerfile.migrations << 'EOF'
FROM postgres:15

COPY *.sql /migrations/
COPY run_migrations.sh /usr/local/bin/

RUN chmod +x /usr/local/bin/run_migrations.sh

CMD ["/usr/local/bin/run_migrations.sh"]
EOF
```

Build the migration container:

```bash
docker build -f Dockerfile.migrations -t db-migrations .
```

Run migrations using the dedicated container:

```bash
docker run --rm \
  --network webapp-network \
  -e PGHOST=postgres-db \
  -e PGUSER=webapp_user \
  -e PGPASSWORD=secure_password123 \
  -e PGDATABASE=webapp_db \
  db-migrations
```

---

ðŸš¨ Troubleshooting Tips

âš¡ Common Issues and Solutions

Issue Symptoms Solution
Container fails to start Port conflict error Check if port 5432 is already in use: netstat -tlnp \| grep 5432
Connection refused errors Apps can't connect to DB Ensure containers are on the same network, verify network configuration
Data not persisting Data lost after restart Verify volume mounting: docker volume inspect postgres-data
Authentication failures Login errors Double-check environment variables and password requirements
Migration failures SQL errors in migration Check SQL syntax, verify file permissions

---

ðŸ† Best Practices

ðŸ”’ Security Considerations

Â· ðŸ” Use strong passwords for database users
Â· ðŸŒ Limit network exposure by using custom networks
Â· ðŸ“¦ Regularly update PostgreSQL images
Â· ðŸ—ï¸ Use secrets management for production environments

âš¡ Performance Optimization

Â· ðŸ§  Configure appropriate memory settings for PostgreSQL
Â· ðŸ·ï¸ Use specific PostgreSQL versions instead of 'latest'
Â· ðŸ“Š Monitor container resource usage
Â· ðŸ“ Implement proper indexing strategies

ðŸ’½ Data Management

Â· ðŸ’¾ Always use volumes for persistent data
Â· ðŸ—ƒï¸ Implement regular backup strategies
Â· ðŸ”„ Test data recovery procedures
Â· ðŸ“ˆ Monitor disk space usage

---

ðŸŽ‰ Conclusion

ðŸ What You've Accomplished

In this lab, you have successfully:

1. ðŸš€ Deployed PostgreSQL in Docker â€“ Learned to pull and run PostgreSQL containers with proper configuration
2. ðŸ’¾ Implemented Persistent Storage â€“ Configured Docker volumes for data persistence
3. ðŸ”— Connected Applications â€“ Created Python and Node.js apps that connect to containerized PostgreSQL
4. ðŸ”„ Performed Database Migrations â€“ Implemented migration system using Docker containers
5. ðŸ† Established Best Practices â€“ Learned networking, security, and data persistence concepts

ðŸ’¡ Real-World Applications

These skills are directly applicable to:

Â· ðŸ› ï¸ Development Environments â€“ Quickly spinning up consistent database environments
Â· ðŸ§ª Testing Scenarios â€“ Creating isolated database instances for automated testing
Â· ðŸ—ï¸ Microservices Architecture â€“ Managing database containers in containerized applications
Â· âš™ï¸ DevOps Practices â€“ Implementing database deployment in CI/CD pipelines

ðŸš€ Next Steps

The techniques demonstrated form the foundation for:

Â· ðŸ³ Advanced container orchestration with Kubernetes
Â· ðŸ”„ Database clustering and replication
Â· ðŸ­ Production deployment strategies
Â· ðŸ“œ Docker Certified Associate certification preparation

ðŸŒŸ Pro Tip: Understanding how to properly containerize and manage databases is a crucial skill for modern software development practices and cloud-native applications.

```